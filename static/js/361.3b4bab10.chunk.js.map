{"version":3,"file":"static/js/361.3b4bab10.chunk.js","mappings":"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","sources":["PART_06_Problem_Data_Model_Train_Validation/LAB_Web_03_MPGPrediction/index.ts"],"sourcesContent":["import * as tf from '@tensorflow/tfjs';\r\nimport * as tfvis from '@tensorflow/tfjs-vis';\r\nimport '@tensorflow/tfjs-backend-webgl';\r\n\r\nexport class Solution {\r\n  public destroy() {\r\n\r\n  }\r\n  constructor(id: string) {\r\n    //  https://js.tensorflow.org/api/latest/\r\n    console.log(\"Let's learn TF JS !!\");\r\n    console.log(\"==============================\");\r\n\r\n    // const data  = await getData()\r\n\r\n    //   const model = createModel();\r\n    //   tfvis.show.modelSummary({name: 'Model Summary'}, model);\r\n\r\n    execute();\r\n\r\n    console.log('Playground done!');\r\n  }\r\n};\r\nconst execute = async () => {\r\n  const data = await getData();\r\n  console.log(data);\r\n  visData(data);\r\n\r\n  const tensor = await convertToTensor(data);\r\n  console.log(tensor)\r\n\r\n  const model = createModel()\r\n\r\n  await trainModel(model, tensor.inputs, tensor.labels);\r\n\r\n  testModel(model, data, tensor);\r\n\r\n}\r\nconst getData = async () => {\r\n  const carsDataResponse = await fetch('https://storage.googleapis.com/tfjs-tutorials/carsData.json');\r\n  const carsData = await carsDataResponse.json();\r\n  const cleaned = carsData.map(car => ({\r\n    mpg: car.Miles_per_Gallon,\r\n    horsepower: car.Horsepower,\r\n  }))\r\n    .filter(car => (car.mpg != null && car.horsepower != null));\r\n\r\n  return cleaned;\r\n};\r\n\r\nconst visData = async (data) => {\r\n  const values = data.map(d => ({\r\n    x: d.horsepower,\r\n    y: d.mpg,\r\n  }));\r\n\r\n  tfvis.render.scatterplot(\r\n    { name: 'Horsepower v MPG' },\r\n    { values },\r\n    {\r\n      xLabel: 'Horsepower',\r\n      yLabel: 'MPG',\r\n      height: 300\r\n    }\r\n  );\r\n\r\n}\r\n\r\nconst createModel = () => {\r\n  // Create a sequential model\r\n  const model = tf.sequential();\r\n\r\n  // Add a single input layer\r\n  model.add(tf.layers.dense({ inputShape: [1], units: 1, useBias: true }));\r\n\r\n  // Add an output layer\r\n  model.add(tf.layers.dense({ units: 1, useBias: true }));\r\n\r\n  return model;\r\n}\r\n\r\n\r\nconst convertToTensor = async (data) => {\r\n  // Wrapping these calculations in a tidy will dispose any\r\n  // intermediate tensors.\r\n\r\n  return tf.tidy(() => {\r\n    // Step 1. Shuffle the data\r\n    tf.util.shuffle(data);\r\n\r\n    // Step 2. Convert data to Tensor\r\n    const inputs = data.map(d => d.horsepower)\r\n    const labels = data.map(d => d.mpg);\r\n\r\n    const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);\r\n    const labelTensor = tf.tensor2d(labels, [labels.length, 1]);\r\n\r\n    //Step 3. Normalize the data to the range 0 - 1 using min-max scaling\r\n    const inputMax = inputTensor.max();\r\n    const inputMin = inputTensor.min();\r\n    const labelMax = labelTensor.max();\r\n    const labelMin = labelTensor.min();\r\n\r\n    const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));\r\n    const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));\r\n\r\n    return {\r\n      inputs: normalizedInputs,\r\n      labels: normalizedLabels,\r\n      // Return the min/max bounds so we can use them later.\r\n      inputMax,\r\n      inputMin,\r\n      labelMax,\r\n      labelMin,\r\n    }\r\n  });\r\n}\r\n\r\nconst trainModel = async (model, inputs, labels) => {\r\n  // Prepare the model for training.\r\n  model.compile({\r\n    optimizer: tf.train.adam(),\r\n    loss: tf.losses.meanSquaredError,\r\n    metrics: ['mse'],\r\n  });\r\n\r\n  const batchSize = 32;\r\n  const epochs = 30;\r\n\r\n  return await model.fit(inputs, labels, {\r\n    batchSize,\r\n    epochs,\r\n    shuffle: true,\r\n    callbacks: tfvis.show.fitCallbacks(\r\n      { name: 'Training Performance' },\r\n      ['loss', 'mse'],\r\n      { height: 200, callbacks: ['onEpochEnd'] }\r\n    )\r\n  });\r\n}\r\n\r\nconst testModel = (model, inputData, normalizationData) => {\r\n  const { inputMax, inputMin, labelMin, labelMax } = normalizationData;\r\n\r\n  // Generate predictions for a uniform range of numbers between 0 and 1;\r\n  // We un-normalize the data by doing the inverse of the min-max scaling\r\n  // that we did earlier.\r\n  const [xs, preds] = tf.tidy(() => {\r\n\r\n    const xs = tf.linspace(0, 1, 100);\r\n    const preds = model.predict(xs.reshape([100, 1]));\r\n\r\n    const unNormXs = xs.mul(inputMax.sub(inputMin)).add(inputMin);\r\n\r\n    const unNormPreds = preds.mul(labelMax.sub(labelMin)).add(labelMin);\r\n\r\n    // Un-normalize the data\r\n    return [unNormXs.dataSync(), unNormPreds.dataSync()];\r\n  });\r\n\r\n\r\n  const predictedPoints = Array.from(xs).map((val, i) => {\r\n    return { x: val, y: preds[i] }\r\n  });\r\n\r\n  const originalPoints = inputData.map(d => ({\r\n    x: d.horsepower, y: d.mpg,\r\n  }));\r\n\r\n\r\n  tfvis.render.scatterplot(\r\n    { name: 'Model Predictions vs Original Data' },\r\n    { values: [originalPoints, predictedPoints], series: ['original', 'predicted'] },\r\n    {\r\n      xLabel: 'Horsepower',\r\n      yLabel: 'MPG',\r\n      height: 300\r\n    }\r\n  );\r\n}"],"names":["Solution","id","console","log","execute","getData","data","visData","convertToTensor","tensor","model","createModel","trainModel","inputs","labels","testModel","fetch","carsDataResponse","json","carsData","cleaned","map","car","mpg","Miles_per_Gallon","horsepower","Horsepower","filter","values","d","x","y","tfvis","name","xLabel","yLabel","height","tf","add","inputShape","units","useBias","inputTensor","length","labelTensor","inputMax","max","inputMin","min","labelMax","labelMin","sub","div","compile","optimizer","loss","metrics","fit","batchSize","epochs","shuffle","callbacks","inputData","normalizationData","xs","preds","predict","reshape","unNormXs","mul","unNormPreds","dataSync","predictedPoints","Array","from","val","i","originalPoints","series"],"sourceRoot":""}