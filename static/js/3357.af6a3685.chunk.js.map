{"version":3,"file":"static/js/3357.af6a3685.chunk.js","mappings":"iTAIaA,EAAQ,0CAIjB,aAAkC,IAAD,EAArBC,EAAU,uDAAG,QAAM,gBAC3B,cAAMA,IAHVC,gBAAU,EAIN,IAAMC,EAAQ,EAAKA,MACnB,EAAKC,OAAOC,SAASC,IAAI,EAAG,GAAI,IAEhC,IAGMC,EAAQ,wFAIRC,EAAM,IAAIC,MAChBD,EAAIE,IAAMH,EACVC,EAAIG,YAAc,YAClBH,EAAII,OAAS,WACTC,EAAeL,EACnB,EAGA,IAAMK,EAAiB,SAACL,GAGpB,IAAMM,EAAO,GAGPC,EAAQP,EAAIO,MACZC,EAASR,EAAIQ,OAGbC,EAAYF,EAAK,GACjBG,EAAYF,EAAM,GAElBG,EAASC,SAASC,cAAc,UACtCF,EAAOJ,MAAQA,EACfI,EAAOH,OAASA,EAChB,EAAKM,QAAQC,OAAOJ,GACpB,IAAMK,EAAML,EAAOM,WAAW,KAAM,CAACC,oBAAoB,IAEzDF,EAAIG,UAAUnB,EAAK,EAAG,GAGtB,IADA,IAAMoB,EAAW,GACRC,EAAI,EAAGA,EAlBH,KAkBeA,EACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,IAAQgB,EAAG,CAC3B,IAAIC,EAAMP,EAAIQ,aAAaF,EAAIb,EAAWY,EAAIX,EAAW,EAAG,GAAGe,KAE3DC,EAlBG,MAiBIC,EAAAA,EAAAA,WAAUJ,EAAI,GAAK,IAAKA,EAAI,GAAK,IAAKA,EAAI,GAAK,KAE1DH,EAASQ,KAAKN,EAAKhB,GAAae,EAAKQ,GAAaH,EACtD,CAIJ,IADA,IAAMI,EAAQ,GACLT,EAAI,EAAGA,EAAIQ,KAAYR,EAC5B,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,KAAYgB,EAAG,CAC/B,IAAIS,EAAQT,EAAKD,EAAIf,EACrBwB,EAAMF,KAAKG,EAAOA,EAAQzB,EAAMyB,EAAQ,GACxCD,EAAMF,KAAKG,EAAQ,EAAGA,EAAQzB,EAAMyB,EAAQzB,EAAO,EACvD,CAGJ,IAAM0B,EAAW,IAAIC,EAAAA,IAAyB,CAE1CC,cAAc,EACdC,aAAa,IAEXC,EAAW,IAAIH,EAAAA,IACrBG,EAASC,SAASP,GAClBM,EAASE,aAAa,WAAY,IAAIL,EAAAA,IAA6Bb,EAAU,IAE7EgB,EAASG,uBACTH,EAASI,qBAET,IAAMC,EAAO,IAAIR,EAAAA,IAAWG,EAAUJ,GACtCS,EAAKC,QAAkB,GAAVC,KAAKC,IAClBjD,EAAMkD,IAAIJ,GAEV,EAAKK,OACT,EAAC,QACL,CAAC,iBAlFgB,CAASC,EAAAA,c","sources":["PART_11_Web_Visualization_3D_for_GIS/LAB_Web_08_Mesh-Terrain/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, RGBtoGray } from '../../lib';\r\n\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    pointLight: THREE.PointLight\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n        const scene = this.scene;\r\n        this.camera.position.set(0, 80, 80);\r\n\r\n        const path0 = 'https://upload.wikimedia.org/wikipedia/commons/5/57/Heightmap.png';\r\n        const path1 = 'https://upload.wikimedia.org/wikipedia/commons/1/15/Srtm_ramp2.world.21600x10800.jpg';\r\n        const path2 = 'https://raw.githubusercontent.com/NamjuLee/data/master/img/heightMap/Heightmap_01.png';\r\n        const path3 = 'https://raw.githubusercontent.com/NamjuLee/data/master/img/heightMap/Heightmap_02.jpg';\r\n        const path4 = 'https://raw.githubusercontent.com/NamjuLee/data/master/img/heightMap/Heightmap_03.jpg';\r\n\r\n\r\n        const img = new Image(); // Create new img element\r\n        img.src = path3;\r\n        img.crossOrigin = \"Anonymous\";\r\n        img.onload = () => {\r\n            buildMeshByImg(img);\r\n        }\r\n\r\n\r\n        const buildMeshByImg = (img) => {\r\n            // ................................................................................\r\n            // your code goes here\r\n            const xNum = 50;\r\n            const yNum = 50;\r\n\r\n            const width = img.width;\r\n            const height = img.height;\r\n            const zScale = 5.5;\r\n\r\n            const xInterval = width / (xNum - 1.0);\r\n            const yInterval = height / (yNum - 1.0);\r\n\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            this.hostDiv.append(canvas);\r\n            const ctx = canvas.getContext('2d', {willReadFrequently: true} );\r\n    \r\n            ctx.drawImage(img, 0, 0);\r\n\r\n            const vertices = [];\r\n            for (let y = 0; y < yNum; ++y) {\r\n                for (let x = 0; x < xNum; ++x) {\r\n                    let col = ctx.getImageData(x * xInterval, y * yInterval, 1, 1).data;\r\n                    let zVal = RGBtoGray(col[0] / 255, col[1] / 255, col[2] / 255);\r\n                    let z = -zVal * zScale;\r\n                    vertices.push(x - (xNum * 0.5), y - (yNum * 0.5), z);\r\n                }\r\n            }\r\n\r\n            const faces = [];\r\n            for (let y = 0; y < yNum - 1; ++y) {\r\n                for (let x = 0; x < xNum - 1; ++x) {\r\n                    let index = x + (y * xNum);\r\n                    faces.push(index, index + xNum, index + 1, );\r\n                    faces.push(index + 1, index + xNum, index + xNum + 1, );\r\n                }\r\n            }\r\n\r\n            const material = new THREE.MeshNormalMaterial({\r\n                // side: THREE.DoubleSide,\r\n                vertexColors: true,\r\n                flatShading: false,\r\n            });\r\n            const geometry = new THREE.BufferGeometry();\r\n            geometry.setIndex(faces);\r\n            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n\r\n            geometry.computeVertexNormals();\r\n            geometry.computeBoundingBox();\r\n            \r\n            const mesh = new THREE.Mesh(geometry, material);\r\n            mesh.rotateX(Math.PI * 0.5);\r\n            scene.add(mesh);\r\n\r\n            this.start();\r\n        }\r\n    }\r\n\r\n}\r\n"],"names":["Solution","id","pointLight","scene","camera","position","set","path3","img","Image","src","crossOrigin","onload","buildMeshByImg","xNum","width","height","xInterval","yInterval","canvas","document","createElement","hostDiv","append","ctx","getContext","willReadFrequently","drawImage","vertices","y","x","col","getImageData","data","z","RGBtoGray","push","yNum","faces","index","material","THREE","vertexColors","flatShading","geometry","setIndex","setAttribute","computeVertexNormals","computeBoundingBox","mesh","rotateX","Math","PI","add","start","RendererThree"],"sourceRoot":""}