{"version":3,"file":"static/js/8636.20b7b7f1.chunk.js","mappings":"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","sources":["PART_11_Web_Visualization_3D_for_GIS/Slowzone_01_Point/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, } from '../../lib';\r\nimport { getJSONFromURL, distanceTo, MercatorProjection } from 'njscore';\r\n\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    positions;\r\n    geometry;\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    pointer = new THREE.Vector2();\r\n\r\n    mesh: THREE.Points;\r\n\r\n    sphere: THREE.Mesh;\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Points.threshold = 0.8;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n        this.camera.position.set(0, 40, 48);\r\n\r\n        // ................................................................................\r\n        // your code goes here\r\n        getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            this.renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n            this.start();\r\n        });\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        this.pointer.x = (e.offsetX / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (e.offsetY / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersections = this.raycaster.intersectObjects([this.mesh], false);\r\n        const intersection = (intersections.length) > 0 ? intersections[0] : null;\r\n\r\n        if (intersection !== null) {\r\n            this.sphere.position.set(intersection.point.x, intersection.point.y, intersection.point.z);\r\n        }\r\n\r\n        let numVertices = this.mesh.geometry.attributes.position.count;\r\n        for (let i = 0; i < numVertices; i++) {\r\n            let o = this.mesh.geometry.attributes.position;\r\n\r\n            let x = o.getX(i);\r\n            let y = o.getY(i);\r\n            let z = o.getZ(i)\r\n\r\n            y = Math.sin(9 * x * z + this.t * 5)\r\n\r\n            y = y < 0 ? 0 : y;\r\n\r\n            let p = new THREE.Vector3(x, y, z);\r\n\r\n            this.mesh.geometry.attributes.position.setXYZ(i, p.x, p.y, p.z);\r\n\r\n            if (intersection !== null) {\r\n                y = distanceTo(x, y, z, intersection.point.x, intersection.point.y, intersection.point.z) / 30\r\n            }\r\n            this.mesh.geometry.attributes.color.setXYZ(i, y, 1 - y, 0);\r\n        }\r\n        this.mesh.geometry.attributes.position.needsUpdate = true;\r\n        this.mesh.geometry.attributes.color.needsUpdate = true;\r\n        this.mesh.geometry.computeVertexNormals();\r\n    }\r\n    public renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.75 });\r\n\r\n        const positions = [];\r\n        const colors = [];\r\n\r\n        const xOFf = -15478803.88731685;\r\n        const yOFf = -4766681.448690384;\r\n        const scale = 0.01;\r\n\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const route = paths[i]\r\n\r\n            for (let j = 0; j < route.length; ++j) {\r\n                for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                    const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                    const x = (xPro + xOFf) * scale\r\n                    const y = (yPro + yOFf) * scale\r\n\r\n                    positions.push(x, 0, y)\r\n                    colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        geometry.computeBoundingSphere();\r\n        this.positions = positions;\r\n        this.geometry = geometry;\r\n        this.mesh = new THREE.Points(geometry, material);\r\n        scene.add(this.mesh);\r\n    }\r\n};"],"names":["Solution","id","streetOSM","routesTreated","routesControl","zones30","positions","geometry","raycaster","THREE","pointer","mesh","sphere","renderPoints","scene","paths","color","material","vertexColors","size","colors","i","length","route","j","k","MercatorProjection","x","y","push","setAttribute","computeBoundingSphere","add","light","camera","params","Points","threshold","far","sphereGeometry","sphereMaterial","position","set","getJSONFromURL","then","data","start","e","this","offsetX","hostDiv","clientWidth","offsetY","clientHeight","setFromCamera","intersections","intersectObjects","intersection","point","z","numVertices","attributes","count","o","getX","getY","getZ","Math","sin","t","p","setXYZ","distanceTo","needsUpdate","computeVertexNormals","RendererThree"],"sourceRoot":""}