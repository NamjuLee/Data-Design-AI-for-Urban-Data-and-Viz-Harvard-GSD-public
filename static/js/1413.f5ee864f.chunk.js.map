{"version":3,"file":"static/js/1413.f5ee864f.chunk.js","mappings":"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","sources":["PART_11_Web_Visualization_3D_for_GIS/LAB_Web_13_Voxel/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, getCSVFromURL } from '../../lib';\r\n\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    pointLight: THREE.PointLight\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n        const scene = this.scene;\r\n        this.camera.position.set(0, 9, 9);\r\n\r\n        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.55);\r\n        this.scene.add(ambientLight);\r\n\r\n        this.pointLight = new THREE.PointLight(0xffffff, 0.75);\r\n        this.pointLight.position.x = 10;\r\n        this.scene.add(this.pointLight);\r\n\r\n        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.55);\r\n        hemiLight.color.setHSL(0.6, 1, 0.6);\r\n        hemiLight.groundColor.setHSL(0.095, 1, 0.75);\r\n        hemiLight.position.set(0, 50, 0);\r\n        scene.add(hemiLight);\r\n\r\n        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n        dirLight.color.setHSL(1, 1, 1);\r\n        dirLight.position.set(- 1, 1.75, 1);\r\n        dirLight.position.multiplyScalar(30);\r\n        dirLight.castShadow = true;\r\n\r\n        const val = 1; // for quality of the shadow in the scene\r\n        dirLight.shadow.camera.left = - val;\r\n        dirLight.shadow.camera.right = val;\r\n        dirLight.shadow.camera.top = val;\r\n        dirLight.shadow.camera.bottom = - val;\r\n\r\n        dirLight.shadow.camera.far = 100;\r\n        dirLight.shadow.bias = - 0.00001;\r\n        dirLight.shadow.mapSize.width = 2048;\r\n        dirLight.shadow.mapSize.height = 2048;\r\n        scene.add(dirLight);\r\n\r\n\r\n        const distance = (x, y, z, xx, yy, zz) => {\r\n            return Math.sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y) + (zz - z) * (zz - z));\r\n        }\r\n\r\n        // https://en.wikipedia.org/wiki/Wavefront_.obj_file\r\n        const URL_OBJ = 'https://raw.githubusercontent.com/McNopper/OpenGL/master/Binaries/bunny.obj';\r\n        const geometryObj = {\r\n            boundingBox: [],\r\n            vertex: []\r\n        }\r\n\r\n        getCSVFromURL(URL_OBJ).then((obj) => {\r\n            const data = obj.split('\\n');\r\n\r\n            geometryObj.boundingBox = [\r\n                [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE],\r\n                [Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE]\r\n            ]\r\n\r\n            for (let i = 0; i < data.length; ++i) {\r\n                const ln = data[i].split(' ');\r\n                if (ln[0] === 'v') {\r\n                    // console.log(ln)\r\n                    geometryObj.vertex.push([+ln[1], +ln[2], +ln[3], 0]); // the last value used for checking isVisiting or not.\r\n\r\n                    // get min and max vector from the individual vertex by this loop\r\n                    geometryObj.boundingBox[0][0] = geometryObj.boundingBox[0][0] > +ln[1] ? +ln[1] : geometryObj.boundingBox[0][0];\r\n                    geometryObj.boundingBox[0][1] = geometryObj.boundingBox[0][1] > +ln[2] ? +ln[2] : geometryObj.boundingBox[0][1];\r\n                    geometryObj.boundingBox[0][2] = geometryObj.boundingBox[0][2] > +ln[3] ? +ln[3] : geometryObj.boundingBox[0][2];\r\n\r\n                    geometryObj.boundingBox[1][0] = geometryObj.boundingBox[1][0] < +ln[1] ? +ln[1] : geometryObj.boundingBox[1][0];\r\n                    geometryObj.boundingBox[1][1] = geometryObj.boundingBox[1][1] < +ln[2] ? +ln[2] : geometryObj.boundingBox[1][1];\r\n                    geometryObj.boundingBox[1][2] = geometryObj.boundingBox[1][2] < +ln[3] ? +ln[3] : geometryObj.boundingBox[1][2];\r\n                }\r\n            }\r\n            voxelization(geometryObj);\r\n        });\r\n\r\n        const voxelization = (obj) => {\r\n            // ................................................................................\r\n            // your code goes here\r\n\r\n            const theDis = .07;\r\n\r\n            const xNum = 15;\r\n            const yNum = 15;\r\n            const zNum = 15;\r\n\r\n            const xInterval = (obj.boundingBox[1][0] - obj.boundingBox[0][0]) / (xNum - 1);\r\n            const yInterval = (obj.boundingBox[1][1] - obj.boundingBox[0][1]) / (yNum - 1);\r\n            const zInterval = (obj.boundingBox[1][2] - obj.boundingBox[0][2]) / (zNum - 1);\r\n            console.log('xInterval', xInterval, 'yInterval', yInterval, 'zInterval', zInterval)\r\n\r\n            const listVoxel = [];\r\n\r\n            for (let z = 0; z < zNum; ++z) {\r\n                const theZ = obj.boundingBox[0][2] + z * zInterval;\r\n                for (let y = 0; y < yNum; ++y) {\r\n                    const theY = obj.boundingBox[0][1] + y * yInterval;\r\n                    for (let x = 0; x < xNum; ++x) {\r\n                        const theX = obj.boundingBox[0][0] + x * xInterval;\r\n\r\n                        let needLoop = true;\r\n                        for (let i = 0; i < obj.vertex.length; i += 1) {\r\n                            const v = obj.vertex[i];\r\n\r\n                            if (v[3] === 0) {\r\n                                const d = distance(theX, theY, theZ, v[0], v[1], v[2]);\r\n                                if (d < theDis) {\r\n                                    obj.vertex[i][3] = 1;\r\n                                    listVoxel.push([theX, theY, theZ]);\r\n                                    needLoop = false;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (!needLoop) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // console.log(listVoxel)\r\n            // console.log('done!!');\r\n\r\n            for (let i = 0; i < listVoxel.length; ++i) {\r\n                // console.log(i);\r\n                let geometryBox = new THREE.BoxGeometry(xInterval, yInterval, zInterval);\r\n                // geometryBox.computeBoundingSphere();\r\n                // geometryBox.computeVertexNormals();\r\n                geometryBox.computeVertexNormals();\r\n                geometryBox.computeBoundingBox();\r\n\r\n                let materialBox = new THREE.MeshStandardMaterial({ color: 0x967bb6 });\r\n                let meshCube = new THREE.Mesh(geometryBox, materialBox);\r\n\r\n                meshCube.position.x = listVoxel[i][0];\r\n                meshCube.position.y = listVoxel[i][1];\r\n                meshCube.position.z = listVoxel[i][2];\r\n                meshCube.castShadow = true;\r\n                meshCube.receiveShadow = true;\r\n                scene.add(meshCube);\r\n\r\n            }\r\n\r\n            this.start();\r\n        }\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        var matrix = new THREE.Matrix4();\r\n        matrix.makeRotationY(Math.PI * 0.011);\r\n        this.pointLight.position.applyMatrix4(matrix);\r\n    }\r\n}\r\n"],"names":["Solution","id","pointLight","scene","camera","position","set","ambientLight","THREE","add","x","hemiLight","color","setHSL","groundColor","dirLight","multiplyScalar","castShadow","val","shadow","left","right","top","bottom","far","bias","mapSize","width","height","distance","y","z","xx","yy","zz","Math","sqrt","URL_OBJ","geometryObj","boundingBox","vertex","getCSVFromURL","then","obj","data","split","Number","MAX_VALUE","MIN_VALUE","i","length","ln","push","voxelization","xInterval","yInterval","zInterval","console","log","listVoxel","theZ","theY","theX","needLoop","v","geometryBox","computeVertexNormals","computeBoundingBox","materialBox","meshCube","receiveShadow","start","matrix","makeRotationY","PI","this","applyMatrix4","RendererThree"],"sourceRoot":""}